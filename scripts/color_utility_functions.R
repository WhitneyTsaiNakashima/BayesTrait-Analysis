clean_data <- function(patchdd) {
  patchdd %>% select(starts_with("species") | ends_with("colors")) -> pcolors
  
  pcolors %>% select(-starts_with("Patch")) -> compatches
  
  compatches %>% rename_with(~str_remove(., '_colors')) %>%
    rename_all(tolower) -> compatches
  
  xx <- colnames(compatches)
  patchnames <- xx[xx !="species"] 
  patch_dfs  <- vector(mode="list", length = length(patchnames) ) #empty vector to hold patch color dfs
  
  for(ii in 1:length(patchnames)){
    patch <- patchnames[ii]
    select(compatches, species, patch) %>% plabeler -> temp_df
    patch_dfs[ii] <- list(temp_df)
    names(patch_dfs)[ii] <- patch
  }
  patch_dfs
}

match_tree_and_data <- function(tree, dat){
  ## given a tree frame and a data frame, return data and tree pruned to match each other
  nc_res <- name.check(tree, dat)
  ## drop tips without data
  pruned_tree <- drop.tip(tree, nc_res$tree_not_data)
  in_data <- intersect(dat$species, tree$tip.label)
  pruned_data <- subset(dat, dat$species %in% in_data)
  res <- name.check(pruned_tree, pruned_data)
  if (res == "OK"){
    return(c(pruned_tree, pruned_data))
  }
  else{
    return(NULL)
  }
}


get_dyads <- function(df){
  ## makes a master data frame containing dfs with species, col1, col2 for runpair
  colnames(df)[colnames(df) %in% c("black", "white", "grey", "brown",  "orange", "yellow", "green", "blue")] -> nn
  combn(nn, 2) -> col_pairs

  num_dyads <- length(col_pairs[1,])
  cdfs <- vector(mode="list", length = num_dyads ) #empty vector to hold dyad data frames

  for (ii in 1:num_dyads){
    #get df for
    cols <-  c("species", col_pairs[,ii])
    df %>% select(starts_with(cols)) ->  temp
    cdfs[[ii]] <- temp
  }
  return(cdfs)
}

create_dep_restriction <- function(index) {
  #creates restricted dep input files for BayesTraitsV3 executable 
  dir <- getwd()
  
  dep_vec <- c("3", "2", "burnin 20000", "iterations 2000000", "PriorAll exp 10", "Stones 100 3000", "cores 1", "Res q12 q21", "Res q13 q31", "Res q24 q42", "Res q34 q43", paste0("LogFile ", "Dep_Run", index))
  write(c(dep_vec, "run"), file = paste0(dir, "/dep_inputfile", index, ".txt"))
  
  sink("restrict_inputs.sh", append = TRUE)
  cat(paste("/home/analysis/BayesTraits/BayesTraitsV3",
            paste0(dir, "/tree.nex"), 
            paste0(dir, "/data", index, ".txt"),
            paste0("< ", dir, "/dep_inputfile", index, ".txt"),
            "&"))
  cat("\n")
  sink()
}

create_ind_restriction <- function(index) {
  #creates restricted ind input files for BayesTraitsV3 executable 
  dir <- getwd()
  
  ind_vec <- c("2", "2", "burnin 20000", "iterations 2000000", "PriorAll exp 10", "Stones 100 3000", "cores 1", "Res alpha1 beta1", "Res alpha2 beta2", paste0("LogFile ", "Ind_Run", index))
  write(c(ind_vec, "run"), file = paste0(dir, "/ind_inputfile", index, ".txt"))
  
  sink("restrict_inputs.sh", append = TRUE)
  cat(paste("/home/analysis/BayesTraits/BayesTraitsV3",
            paste0(dir, "/tree.nex"), 
            paste0(dir, "/data", index, ".txt"),
            paste0("< ", dir, "/ind_inputfile", index, ".txt"),
            "&"))
  cat("\n")
  sink()
}

createInput <- function(data, index) {
  #creates input files for BayesTraitsV3 executable and appends each call to Bayestraits to main_inputs.sh
  
  dir <- getwd()
  ind_vec <- c("2", "2", "burnin 20000", "iterations 2000000", "PriorAll exp 10", "Stones 100 3000", "cores 1", paste0("LogFile ", "Ind_Run", index))
  write(c(ind_vec, "run"), file = paste0(dir, "/ind_inputfile", index, ".txt"))
  
  write.table(data, file = paste0(dir, "/data", index, ".txt"), quote = F, col.names = F, row.names = F)
  
  dep_vec <- c("3", "2", "burnin 20000", "iterations 2000000", "PriorAll exp 10", "Stones 100 3000", "cores 1", paste0("LogFile ", "Dep_Run", index))
  write(c(dep_vec, "run"), file = paste0(dir, "/dep_inputfile", index, ".txt"))
  
  sink("main_inputs.sh", append = TRUE)
  cat(paste("/home/analysis/BayesTraits/BayesTraitsV3",
            paste0(dir, "/tree.nex"), 
            paste0(dir, "/data", index, ".txt"),
            paste0("< ", dir, "/ind_inputfile", index, ".txt"),
            "&"))
  cat("\n")
  cat(paste("/home/analysis/BayesTraits/BayesTraitsV3",
            paste0(dir, "/tree.nex"), 
            paste0(dir, "/data", index, ".txt"),
            paste0("< ", dir, "/dep_inputfile", index, ".txt"),
            "&"))
  cat("\n")
  sink()
}

deleteInput <- function(index) {
  #deletes all input files generated by createInput
  dir <- getwd()
  unlink(paste0(dir, "/data", index, ".txt"))
  unlink(paste0(dir, "/ind_inputfile", index, ".txt"))
  unlink(paste0(dir, "/dep_inputfile", index, ".txt"))
}

deleteOutput <- function(index) {
  #deletes all Bayestrait output files after they are parsed
  dir <- getwd()
  unlink(paste0(dir, "/Dep_Run", index, ".Log.txt"))
  unlink(paste0(dir, "/Dep_Run", index, ".Schedule.txt"))
  unlink(paste0(dir, "/Dep_Run", index, ".Stones.txt"))
  
  unlink(paste0(dir, "/Ind_Run", index, ".Log.txt"))
  unlink(paste0(dir, "/Ind_Run", index, ".Schedule.txt"))
  unlink(paste0(dir, "/Ind_Run", index, ".Stones.txt"))
}

parseOutput <- function(index) {
  #parses the Bayestrait output files into a single list of results
  Log <- parse_log(paste0("./Ind_Run", index, ".Log.txt"))
  Schedule <- parse_schedule(paste0("./Ind_Run", index, ".Schedule.txt")) 
  Stones <- parse_stones(paste0("./Ind_Run", index, ".Stones.txt")) 
  ind_res <- list(Log=Log,
                  Schedule=Schedule,
                  Stones=Stones,
                  AncStates=NULL,
                  OutputTrees=NULL)
  
  Log <- parse_log(paste0("./Dep_Run", index, ".Log.txt"))
  Schedule <- parse_schedule(paste0("./Dep_Run", index, ".Schedule.txt")) 
  Stones <- parse_stones(paste0("./Dep_Run", index, ".Stones.txt"))  
  dep_res <- list(Log=Log,
                  Schedule=Schedule,
                  Stones=Stones,
                  AncStates=NULL,
                  OutputTrees=NULL)
  
  res <- bftest(ind_res, dep_res)
  resList <- list("bftest" = res, "ind_res" = ind_res, "dep_res"= dep_res)
  return(resList)
}

writeBayesTree <- function(tree) {
  # writes input tree which is the same for each bayestrait call 
  dir <- getwd()
  ape::write.nexus(tree, file = paste0(dir, "/tree.nex"), translate = T)
}


compareRates <- function(cdfs, tree, silent = TRUE, allowRestrictions = TRUE, patch1 = "NONE", patch2 = "NONE"){  
  dir <- getwd()
  
  if(patch1 != "NONE") {
    dir.create(paste0(dir, "/", patch1, "+", patch2))
    path <- paste0(patch1, "+", patch2, "/")
  }
  else {
    path <- ""
  }
  
  ## mtd = matched trait data
  tt <- tree
  cdfs <- cdfs[1:5]
  
  #creates empty vectors to store results later on
  num_dyads <- length(cdfs)
  bf_res<-vector(mode = "list", length=num_dyads) #holds data from bayestraits
  scores <- numeric(length = num_dyads)
  prefmod <- character(length=num_dyads)
  
  ind_results <- vector(mode = "list", length = num_dyads)
  dep_results <- vector(mode = "list", length = num_dyads)
  
  #create bash script that will run Bayestrait calls in parallel
  file.create("main_inputs.sh")
  
  #append #!/bin/bash to the script
  sink("main_inputs.sh", append = TRUE)
  cat("#!/bin/bash")
  cat("\n")
  sink()
  
  #create tree and other input files
  writeBayesTree(tt)
  
  for(i in seq_along(cdfs)) {
    createInput(cdfs[[i]], i)
  }
  
  sink("main_inputs.sh", append = TRUE)
  cat("wait")
  cat("\n")
  cat("exit")
  cat("\n")
  sink()
  
  #run the parallelized bash script
  
  system("chmod +x main_inputs.sh")
  system("./main_inputs.sh", ignore.stdout = silent)
  
  #parse the Bayestrait output
  
  bf_res <- lapply(seq_along(cdfs), 
                   function(i) {
                     parseOutput(i)
                   })
  
  save(bf_res, file = paste0(path, "bf_res.RData"))
  
  #delete output files
  
  for(i in seq_along(cdfs)) {
    deleteOutput(i)
  }
  
  #call bayestrait again to output second chain
  #bf_res is used for data analysis, bf_res2 checks for convergenc
  
  system("chmod +x main_inputs.sh")
  system("./main_inputs.sh", ignore.stdout = silent)
  
  #parse the Bayestrait output
  
  bf_res2 <- lapply(seq_along(cdfs), 
                   function(i) {
                     parseOutput(i)
                   })
  
  save(bf_res2, file = paste0(path, "bf_res2.RData"))

  unlink("main_inputs.sh")
  
  file.create(paste0(path, "warnings.log"))
  sink(paste0(path, "warnings.log"), append = TRUE)
  cat("Warnings: ")
  cat("\n")
  sink()
  restrict_ind <- numeric(0)
  restrict_dep <- numeric(0)
  
  #check for convergence and ESS
  
  for(i in 1:length(bf_res)) {
    low_ind_size <- FALSE
    low_dep_size <- FALSE
    
    #check effective size of bf_res
    dep_chain1 <- mcmc(bf_res[[i]]$dep_res$Log$results[c(-1, -3)][1:9])
    dep_chain2 <- mcmc(bf_res2[[i]]$dep_res$Log$results[c(-1, -3)][1:9])
    
    ind_chain1 <- mcmc(bf_res[[i]]$ind_res$Log$results[c(-1, -3)][1:5])
    ind_chain2 <- mcmc(bf_res2[[i]]$ind_res$Log$results[c(-1, -3)][1:5])
      
    ind_sizes <- effectiveSize(ind_chain1)
    dep_sizes <- effectiveSize(dep_chain1)
    
    for(j in seq_len(length(ind_sizes))) {
      if(ind_sizes[j] < 200) {
        sink(paste0(path, "warnings.log"), append = TRUE)
        cat(paste("Effective size for parameter", names(ind_sizes)[j], "of independent run", i, "is less than 200 at", round(ind_sizes[j], digits = 2)))
        cat("\n")
        sink()
        low_ind_size <- TRUE
      }
    }
    
    if(low_ind_size) {
      restrict_ind <- c(restrict_ind, i)
    }
    
    for(k in seq_len(length(dep_sizes))) {
      if(dep_sizes[k] < 200) {
        sink(paste0(path, "warnings.log"), append = TRUE)
        cat(paste("Effective size for parameter" , names(dep_sizes)[k], "of dependent run", i, "is less than 200 at", round(dep_sizes[k], digits = 2)))
        cat("\n")
        sink()
        low_dep_size <- TRUE
      }
    }
    
    if(low_dep_size) {
      restrict_dep <- c(restrict_dep, i)
    }
    
    #check gelman diagnostic for ind and dep chains
    combined_ind_chains <- mcmc.list(ind_chain1, ind_chain2)
    combined_dep_chains <- mcmc.list(dep_chain1, dep_chain2)
    
    ind_gelman_results <- gelman.diag(combined_ind_chains)$psrf[, 1]
    dep_gelman_results <- gelman.diag(combined_dep_chains)$psrf[, 1]
    
    for(j in 1:length(ind_gelman_results)) {
      if(ind_gelman_results[j] > 1.1) {
        sink(paste0(path, "warnings.log"), append = TRUE)
        cat(paste("Possible nonconvergence in in parameter", names(ind_gelman_results[j]), "of independent run", i, "due to a high potential scale reduction factor of", round(ind_gelman_results[j], digits = 2)))
        cat("\n")
        sink()
      }
    }
    
    for(k in 1:length(dep_gelman_results)) {
      if(dep_gelman_results[k] > 1.1) {
        sink(paste0(path, "warnings.log"), append = TRUE)
        cat(paste("Possible nonconvergence in parameter", names(dep_gelman_results[k]), "of dependent run", i, "due to a high potential scale reduction factor of", round(dep_gelman_results[k], digits = 2)))
        cat("\n")
        sink()
      }
    }
  }
  
  
  #run Bayestraits with parameter restrictions for low effective sample size runs
  if(length(restrict_dep) != 0 || length(restrict_ind) != 0) {
    file.create("restrict_inputs.sh")
    sink("restrict_inputs.sh", append = TRUE)
    cat("#!/bin/bash")
    cat("\n")
    sink()
    
    file.create(paste0(path, "restrictions.txt"))
    for(index in restrict_dep) {
      sink(paste0(path, "restrictions.txt"), append = TRUE)
      cat(paste0("Dependent restriction for run ", index, " performed"))
      cat("\n")
      sink()
      create_dep_restriction(index)
    }
    
    for(index in restrict_ind) {
      sink(paste0(path, "restrictions.txt"), append = TRUE)
      cat(paste0("Independent restriction for run ", index, " performed"))
      cat("\n")
      sink()
      create_ind_restriction(index)
    }
    
    sink("restrict_inputs.sh", append = TRUE)
    cat("wait")
    cat("\n")
    cat("exit")
    cat("\n")
    sink()
    
    system("chmod +x restrict_inputs.sh")
    system("./restrict_inputs.sh", ignore.stdout = silent)
    
    bf_res_restricted <- lapply(seq_along(cdfs), 
                     function(i) {
                       parseOutput(i)
                     })
    
    save(bf_res_restricted, file = paste0(path, "bf_res_restricted.RData"))
    bf_res <- bf_res_restricted
    unlink("restrict_inputs.sh")
  }
  
  
  #delete all input and output files
  for(i in seq_along(cdfs)) {
    deleteOutput(i)
  }
  
  for(i in seq_along(cdfs)) {
    deleteInput(i)
  }
  

  #extract useful data from the list of parsed results 
  for(ii in 1:length(bf_res)) {
    res <- bf_res[[ii]]
    independent_data <- list(alpha1 = res$ind_res$Log$results$alpha1, beta1 = res$ind_res$Log$results$beta1, alpha2 = res$ind_res$Log$results$alpha2, beta2 = res$ind_res$Log$results$beta2)
    dependent_data <- list(q12 = res$dep_res$Log$results$q12, q13 = res$dep_res$Log$results$q13, q21 = res$dep_res$Log$results$q21, q24 = res$dep_res$Log$results$q24, q31 = res$dep_res$Log$results$q31, q34 = res$dep_res$Log$results$q34, q42 = res$dep_res$Log$results$q42, q43 = res$dep_res$Log$results$q43)
    ind_results[[ii]] <- independent_data
    dep_results[[ii]] <- dependent_data
    scores[ii] <- res$bftest$BayesFactor
    prefmod[ii] <- as.character.factor(res$bftest$BetterModel)
  }

  #create dataframe with mean, center, credible interval

  #all initializations
  alpha1mean <- numeric(0)
  alpha1median <- numeric(0)
  alpha1upperci <- numeric(0)
  alpha1lowerci <- numeric(0)

  alpha2mean <- numeric(0)
  alpha2median <- numeric(0)
  alpha2upperci <- numeric(0)
  alpha2lowerci <- numeric(0)

  beta2mean <- numeric(0)
  beta2median <- numeric(0)
  beta2upperci <- numeric(0)
  beta2lowerci <- numeric(0)

  beta1mean <- numeric(0)
  beta1median <- numeric(0)
  beta1upperci <- numeric(0)
  beta1lowerci <- numeric(0)

  q12mean <- numeric(0)
  q12median <- numeric(0)
  q12upperci <- numeric(0)
  q12lowerci <- numeric(0)

  q13mean <- numeric(0)
  q13median <- numeric(0)
  q13upperci <- numeric(0)
  q13lowerci <- numeric(0)

  q21mean <- numeric(0)
  q21median <- numeric(0)
  q21upperci <- numeric(0)
  q21lowerci <- numeric(0)

  q24mean <- numeric(0)
  q24median <- numeric(0)
  q24upperci <- numeric(0)
  q24lowerci <- numeric(0)

  q31mean <- numeric(0)
  q31median <- numeric(0)
  q31upperci <- numeric(0)
  q31lowerci <- numeric(0)

  q34mean <- numeric(0)
  q34median <- numeric(0)
  q34upperci <- numeric(0)
  q34lowerci <- numeric(0)

  q42mean <- numeric(0)
  q42median <- numeric(0)
  q42upperci <- numeric(0)
  q42lowerci <- numeric(0)

  q43mean <- numeric(0)
  q43median <- numeric(0)
  q43upperci <- numeric(0)
  q43lowerci <- numeric(0)


  for(result in ind_results) {
    for(i in seq_len(length(result))) {
      mean <- mean(result[[i]])
      median <- median(result[[i]])
      ci_95 <- quantile(result[[i]], probs = c(0.025, 0.975))
      ci_95_lower <- ci_95[1]
      ci_95_upper <- ci_95[2]
      if(i == 1) {
        alpha1mean <- c(alpha1mean, mean)
        alpha1median <- c(alpha1median, median)
        alpha1lowerci <- c(alpha1lowerci, ci_95_lower)
        alpha1upperci <- c(alpha1upperci, ci_95_upper)
      }
      else if(i == 2) {
        beta1mean <- c(beta1mean, mean)
        beta1median <- c(beta1median, median)
        beta1lowerci <- c(beta1lowerci, ci_95_lower)
        beta1upperci <- c(beta1upperci, ci_95_upper)
      }
      else if(i == 3) {
        alpha2mean <- c(alpha2mean, mean)
        alpha2median <- c(alpha2median, median)
        alpha2lowerci <- c(alpha2lowerci, ci_95_lower)
        alpha2upperci <- c(alpha2upperci, ci_95_upper)
      }
      else if(i == 4) {
        beta2mean <- c(beta2mean, mean)
        beta2median <- c(beta2median, median)
        beta2lowerci <- c(beta2lowerci, ci_95_lower)
        beta2upperci <- c(beta2upperci, ci_95_upper)
      }
    }
  }

  for(result in dep_results) {
    for(i in seq_len(length(result))) {
      mean <- mean(result[[i]])
      median <- median(result[[i]])
      ci_95 <- quantile(result[[i]], probs = c(0.025, 0.975))
      ci_95_lower <- ci_95[1]
      ci_95_upper <- ci_95[2]
      if(i == 1) {
        q12mean <- c(q12mean, mean)
        q12median <- c(q12median, median)
        q12lowerci <- c(q12lowerci, ci_95_lower)
        q12upperci <- c(q12upperci, ci_95_upper)
      }
      else if(i == 2) {
        q13mean <- c(q13mean, mean)
        q13median <- c(q13median, median)
        q13lowerci <- c(q13lowerci, ci_95_lower)
        q13upperci <- c(q13upperci, ci_95_upper)
      }
      else if(i == 3) {
        q21mean <- c(q21mean, mean)
        q21median <- c(q21median, median)
        q21lowerci <- c(q21lowerci, ci_95_lower)
        q21upperci <- c(q21upperci, ci_95_upper)
      }
      else if(i == 4) {
        q24mean <- c(q24mean, mean)
        q24median <- c(q24median, median)
        q24lowerci <- c(q24lowerci, ci_95_lower)
        q24upperci <- c(q24upperci, ci_95_upper)
      }
      else if(i == 5) {
        q31mean <- c(q31mean, mean)
        q31median <- c(q31median, median)
        q31lowerci <- c(q31lowerci, ci_95_lower)
        q31upperci <- c(q31upperci, ci_95_upper)
      }
      else if(i == 6) {
        q34mean <- c(q34mean, mean)
        q34median <- c(q34median, median)
        q34lowerci <- c(q34lowerci, ci_95_lower)
        q34upperci <- c(q34upperci, ci_95_upper)
      }
      else if(i == 7) {
        q42mean <- c(q42mean, mean)
        q42median <- c(q42median, median)
        q42lowerci <- c(q42lowerci, ci_95_lower)
        q42upperci <- c(q42upperci, ci_95_upper)
      }
      else if(i == 8) {
        q43mean <- c(q43mean, mean)
        q43median <- c(q43median, median)
        q43lowerci <- c(q43lowerci, ci_95_lower)
        q43upperci <- c(q43upperci, ci_95_upper)
      }
    }
  }
  
  ## create a df with the color pairs and model results
  col_pairs <- data.frame()
  for(i in 1:length(cdfs)) {
    names <- names(cdfs[[i]])
    pair <- cbind(names[2], names[3])
    col_pairs <- rbind(col_pairs, pair)
  }
  xx <- col_pairs


  #create two dataframes with the sample statistics for the rate parameters of independent and dependent model results
  tibble(xx[,1],xx[,2], alpha1mean, alpha1median, alpha1lowerci, alpha1upperci, beta1mean, beta1median, beta1lowerci, beta1upperci, alpha2mean, alpha2median, alpha2lowerci, alpha2upperci, beta2mean, beta2median, beta2lowerci, beta2upperci) -> independent_data
  colnames(independent_data) = c("color1", "color2", "alpha1mean", "alpha1median", "alpha1lowerci", "alpha1upperci", "beta1mean", "beta1median", "beta1lowerci", "beta1upperci", "alpha2mean", "alpha2median", "alpha2lowerci", "alpha2upperci", "beta2mean", "beta2median", "beta2lowerci", "beta2upperci")

  tibble(xx[,1],xx[,2], q12mean, q12median, q12lowerci, q12upperci, q13mean, q13median, q13lowerci, q13upperci, q21mean, q21median, q21lowerci, q21upperci, q24mean, q24median, q24lowerci, q24upperci, q31mean, q31median, q31lowerci, q31upperci, q34mean, q34median, q34lowerci, q34upperci, q42mean, q42median, q42lowerci, q42upperci, q43mean, q43median, q43lowerci, q43upperci) -> dependent_data
  colnames(dependent_data) = c("color1", "color2", "q12mean", "q12median", "q12lowerci", "q12upperci", "q13mean", "q13median", "q13lowerci", "q13upperci", "q21mean", "q21median", "q21lowerci", "q21upperci", "q24mean", "q24median", "q24lowerci", "q24upperci", "q31mean", "q31median", "q31lowerci", "q31upperci", "q34mean", "q34median", "q34lowerci", "q34upperci", "q42mean", "q42median", "q42lowerci", "q42upperci", "q43mean", "q43median", "q43lowerci", "q43upperci")
  
  write.csv(independent_data, file = paste0(path, "/independent_result_statistics.csv"), quote = F,)
  write.csv(dependent_data, file = paste0(path, "/dependent_result_statistics.csv"), quote = F,)
  
  #create a dataframe with the preferred model and the score for each pairwise comparison
  tibble(xx[,1],xx[,2], prefmod, scores) -> model_results
  colnames(model_results) = c("color1", "color2", "bestmodel", "bf")

  #replace preferred model label
  model_results %>% mutate(bestmodel = str_replace_all(bestmodel, 'Model 1', 'indep')) %>%  mutate(bestmodel = str_replace_all(bestmodel, 'Model 2', "dep")) -> model_results
  model_results
  write.csv(model_results, file = paste0(path, "all_tanagers_color_bt_results.csv"), quote = F,)
}


